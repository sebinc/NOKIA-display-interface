#ifndef LCD1_H
#define LCD1_H

/////////////////////////////////////////////////////
// SSPCON=0x00;       clock is active low          //
/////////////////////////////////////////////////////

				
#include "includes.h"


////////////////////////////////////////////////////////////////////////////
///////////////DFINITIONS///////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
#define s_clk RC3
#define s_dat RC5
#define cs RB1
#define dc RB0
#define res RB2



//////////////////////////////////////////////////////////////////
//////////Function  declarations//////////////////////////////////
//////////////////////////////////////////////////////////////////



void nokia_spi(unsigned char data);
void lcd_init(void);
void lcd_data(unsigned char);
void lcd_cmd(unsigned char);
void lcd_reset(void);
void lcd_gotoxy(char x,char y);
void lcd_chara(unsigned char);
void lcd_cls(void);
void delay(unsigned char x);
void lcd_str(const char *str);

//////////////////////////////////////////////////////////////////
////////////////  LOOK UP TABLE FOR FONT /////////////////////////
//////////////////////////////////////////////////////////////////

static const unsigned char Lookup [][5] =
{
    { 0x00, 0x00, 0x00, 0x00, 0x00 },  // space
    { 0x00, 0x00, 0x2f, 0x00, 0x00 },   // !
    { 0x00, 0x07, 0x00, 0x07, 0x00 },   // "
    { 0x14, 0x7f, 0x14, 0x7f, 0x14 },   // #
    { 0x24, 0x2a, 0x7f, 0x2a, 0x12 },   // $
    { 0xc4, 0xc8, 0x10, 0x26, 0x46 },   // %
    { 0x36, 0x49, 0x55, 0x22, 0x50 },   // &
    { 0x00, 0x05, 0x03, 0x00, 0x00 },   // '
    { 0x00, 0x1c, 0x22, 0x41, 0x00 },   // (
    { 0x00, 0x41, 0x22, 0x1c, 0x00 },   // )
    { 0x14, 0x08, 0x3E, 0x08, 0x14 },   // *
    { 0x08, 0x08, 0x3E, 0x08, 0x08 },   // +
    { 0x00, 0x00, 0x50, 0x30, 0x00 },   // ,
    { 0x10, 0x10, 0x10, 0x10, 0x10 },   // -
    { 0x00, 0x60, 0x60, 0x00, 0x00 },   // .
    { 0x20, 0x10, 0x08, 0x04, 0x02 },   // /
    { 0x3E, 0x51, 0x49, 0x45, 0x3E },   // 0
    { 0x00, 0x42, 0x7F, 0x40, 0x00 },   // 1
    { 0x42, 0x61, 0x51, 0x49, 0x46 },   // 2
    { 0x21, 0x41, 0x45, 0x4B, 0x31 },   // 3
    { 0x18, 0x14, 0x12, 0x7F, 0x10 },   // 4
    { 0x27, 0x45, 0x45, 0x45, 0x39 },   // 5
    { 0x3C, 0x4A, 0x49, 0x49, 0x30 },   // 6
    { 0x01, 0x71, 0x09, 0x05, 0x03 },   // 7
    { 0x36, 0x49, 0x49, 0x49, 0x36 },   // 8
    { 0x06, 0x49, 0x49, 0x29, 0x1E },   // 9
    { 0x00, 0x36, 0x36, 0x00, 0x00 },   // :
    { 0x00, 0x56, 0x36, 0x00, 0x00 },   // ;
    { 0x08, 0x14, 0x22, 0x41, 0x00 },   // <
    { 0x14, 0x14, 0x14, 0x14, 0x14 },   // =
    { 0x00, 0x41, 0x22, 0x14, 0x08 },   // >
    { 0x02, 0x01, 0x51, 0x09, 0x06 },   // ?
    { 0x32, 0x49, 0x59, 0x51, 0x3E },   // @
    { 0x7E, 0x11, 0x11, 0x11, 0x7E },   // A
    { 0x7F, 0x49, 0x49, 0x49, 0x36 },   // B
    { 0x3E, 0x41, 0x41, 0x41, 0x22 },   // C
    { 0x7F, 0x41, 0x41, 0x22, 0x1C },   // D
    { 0x7F, 0x49, 0x49, 0x49, 0x41 },   // E
    { 0x7F, 0x09, 0x09, 0x09, 0x01 },   // F
    { 0x3E, 0x41, 0x49, 0x49, 0x7A },   // G
    { 0x7F, 0x08, 0x08, 0x08, 0x7F },   // H
    { 0x00, 0x41, 0x7F, 0x41, 0x00 },   // I
    { 0x20, 0x40, 0x41, 0x3F, 0x01 },   // J
    { 0x7F, 0x08, 0x14, 0x22, 0x41 },   // K
    { 0x7F, 0x40, 0x40, 0x40, 0x40 },   // L
    { 0x7F, 0x02, 0x0C, 0x02, 0x7F },   // M
    { 0x7F, 0x04, 0x08, 0x10, 0x7F },   // N
    { 0x3E, 0x41, 0x41, 0x41, 0x3E },   // O
    { 0x7F, 0x09, 0x09, 0x09, 0x06 },   // P
    { 0x3E, 0x41, 0x51, 0x21, 0x5E },   // Q
    { 0x7F, 0x09, 0x19, 0x29, 0x46 },   // R
    { 0x46, 0x49, 0x49, 0x49, 0x31 },   // S
    { 0x01, 0x01, 0x7F, 0x01, 0x01 },   // T
    { 0x3F, 0x40, 0x40, 0x40, 0x3F },   // U
    { 0x1F, 0x20, 0x40, 0x20, 0x1F },   // V
    { 0x3F, 0x40, 0x38, 0x40, 0x3F },   // W
    { 0x63, 0x14, 0x08, 0x14, 0x63 },   // X
    { 0x07, 0x08, 0x70, 0x08, 0x07 },   // Y
    { 0x61, 0x51, 0x49, 0x45, 0x43 },   // Z
    { 0x00, 0x7F, 0x41, 0x41, 0x00 },   // [
    { 0x55, 0x2A, 0x55, 0x2A, 0x55 },   // 55
    { 0x00, 0x41, 0x41, 0x7F, 0x00 },   // ]
    { 0x04, 0x02, 0x01, 0x02, 0x04 },   // ^
    { 0x40, 0x40, 0x40, 0x40, 0x40 },   // _
    { 0x00, 0x01, 0x02, 0x04, 0x00 },   // '
    { 0x20, 0x54, 0x54, 0x54, 0x78 },   // a
    { 0x7F, 0x48, 0x44, 0x44, 0x38 },   // b
    { 0x38, 0x44, 0x44, 0x44, 0x20 },   // c
    { 0x38, 0x44, 0x44, 0x48, 0x7F },   // d
    { 0x38, 0x54, 0x54, 0x54, 0x18 },   // e
    { 0x08, 0x7E, 0x09, 0x01, 0x02 },   // f
    { 0x0C, 0x52, 0x52, 0x52, 0x3E },   // g
    { 0x7F, 0x08, 0x04, 0x04, 0x78 },   // h
    { 0x00, 0x44, 0x7D, 0x40, 0x00 },   // i
    { 0x20, 0x40, 0x44, 0x3D, 0x00 },   // j
    { 0x7F, 0x10, 0x28, 0x44, 0x00 },   // k
    { 0x00, 0x41, 0x7F, 0x40, 0x00 },   // l
    { 0x7C, 0x04, 0x18, 0x04, 0x78 },   // m
    { 0x7C, 0x08, 0x04, 0x04, 0x78 },   // n
    { 0x38, 0x44, 0x44, 0x44, 0x38 },   // o
    { 0x7C, 0x14, 0x14, 0x14, 0x08 },   // p
    { 0x08, 0x14, 0x14, 0x18, 0x7C },   // q
    { 0x7C, 0x08, 0x04, 0x04, 0x08 },   // r
    { 0x48, 0x54, 0x54, 0x54, 0x20 },   // s
    { 0x04, 0x3F, 0x44, 0x40, 0x20 },   // t
    { 0x3C, 0x40, 0x40, 0x20, 0x7C },   // u
    { 0x1C, 0x20, 0x40, 0x20, 0x1C },   // v
    { 0x3C, 0x40, 0x30, 0x40, 0x3C },   // w
    { 0x44, 0x28, 0x10, 0x28, 0x44 },   // x
    { 0x0C, 0x50, 0x50, 0x50, 0x3C },   // y
    { 0x44, 0x64, 0x54, 0x4C, 0x44 }    // z
};

/// ///////lcd initialization/////////////////////////////
//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////

void lcd_init(void)
{
	lcd_reset();
	lcd_cmd(0xA6);  //lcd normal mode
	lcd_cmd(0xA2);//bias 1 over
	lcd_cmd(0xA1);//adc reverse   ,,,A0 for display in reverse order
	lcd_cmd(0xC0);//comm normal
	lcd_cmd(0x24);    //24
	lcd_cmd(0x81);    //81
	lcd_cmd(0x2E);    ///power control
	lcd_cmd(0x2F);
	lcd_cmd(0xE3);//lcd nop
	lcd_cmd(0x2f);
	lcd_cmd(0xAF);//lcd on
	lcd_cmd(0xA5);//lcd all on
	delay(50);
	lcd_cmd(0xAE);//lcd off
	lcd_cls();
	delay(10);
	lcd_cmd(0xAF);//lcd all off
	delay(30);
	lcd_cmd(0xA4);
	return;
}


/// ///////lcd data//////////////


void lcd_data(unsigned char x)
{
	dc=1;
	cs=0;
	
//	spi_sendbyte(l);
	nokia_spi(x);
	cs=1;
}



/// ///////lcd data////////////////////////////


void lcd_cmd(unsigned char c)
{
	dc=0;
	cs=0;
//	spi_sendbyte(c);
	nokia_spi(c);
	cs=1;
}	
		

/// ///////lcd reset//////////////

void lcd_reset(void)
{
	dc=1;
	cs=1;
	delay(50);
	cs=0;

	delay(100);
	cs=1;
	
	delay(250);
}	

//////////////////////////////////////////////////////////////

void lcd_gotoxy(char x_pos,char y_pos)
{
	unsigned char col;
	col=0x12+ y_pos*6;          //font require 5 row
	lcd_cmd(0xB0+x_pos);          //colum
	unsigned char tmp;
	tmp=col>>4;
	lcd_cmd(0x11|tmp);
	lcd_cmd(0x0f&col);     //LSB
}	
	
	
//////////////////////////////////////////////////////////////


void lcd_chara(unsigned char x)
{
	if(x<0x20) return;
	if(x>0x7f) return;

	    unsigned char i,char_data,char_pos;
    	char_pos=x-0x20;
	
     	for(i=0;i<5;i++) // 5 bytes
      	{
	    	
	    	char_data=Lookup[x-32][i];
		
	    	lcd_data(char_data);   ///use ~char_data for white character in black screen
    	}
    	
		lcd_data(0x00);   //blank data b/w characters
 
}   	
	
	
	//////////////////////////////////////////////////////////////
	
	void delay(unsigned char x)
	{
		unsigned char i=x/10;
		for (char j=0;j<i;j++)
		__delay_ms(10);
	}	
		
	
/////////////////////////////////////////////////////////////////////

void lcd_cls()
{
	unsigned char page;
	for(page=0;page<9;page++)        // 9 pages
	{
		lcd_cmd(0xB0+page);
		lcd_cmd(0x11);
		lcd_cmd(0x01);
		for(unsigned char x=96;x>0;x--)      //make all 96 pixels to zero
		lcd_data(0x00);
	}
}			
	
	
////////////////////////////////////////////////////////////////

void lcd_str(const char *str) 
{
	unsigned char k=0;
while (str[k]!=0)
{
  lcd_chara(str[k]);
   k++;
}
}




/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
void nokia_spi(unsigned char data )			// serial write data or command Software SPI
{
for (char c=8;c>0;c--)
	 {
		s_clk=0;
		
		if ((data&0x80)==0)
		s_dat=0;
		else 
		s_dat=1;
		
		
		s_clk=1;
		data=data<<1;
	  }
}






























#endif